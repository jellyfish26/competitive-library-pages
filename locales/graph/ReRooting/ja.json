{
    "ja": {
        "library_name": "全方位木DP",
        "overview": "うーん，説明するの難しいね:(　各頂点を根とした根付き木に関するDPすべてを$O(N)$で解くことが出来る．",
        "explanation_content": "各頂点を根とした根付き木に関するDPを愚直に計算すると$O(N^2)$かかるけど，いくつかの部分木は2回以上呼び出されるのでメモ化して高速化しようというのがアイデア．そこからスターグラフとか色々最悪計算量が$O(N^2)$の時があるので，マージ等のテクニックを使って$O(N)$に落とす．累積和的な発想．もう全方位木DPについてちゃんと説明している人がいるのでそっち見たほうが良いと思います．（僕もそこで理解したつもりだが，競プロなんもわからん）",
        "reference_about": "merge関数はマージするときの関数，2つの引数をマージしたときの値を返す必要があり，モノイドを満たす必要がある．raising関数は根に釣り上げる遷移をするときの関数．型Dataはedgeに持たせておきたい型，型DPはDPするときの型（バグってても知りません）あと，普通は書かないけど自分用にprivate関数のリファレンスも書いてる",
        "dfs_normal_explanation": "頂点$v$から普通に木DPを行なう",
        "dfs_after_explanation": "このライブラリの心臓部．頂点$v$からの木DPの情報を活かして，引数にそこまでの部分木情報を持ちつつdfsする．left_dp,right_dpで各頂点での各方面の部分木情報が得られる．部分木情報は遷移する辺を除いた累積情報をマージすることで作ることが出来る，dfs_normalでは遷移元の辺へは何も情報を入れていないが，ここではその頂点でのすべての情報が必要なので0-indexから見るときに部分木情報をnormal_dpに付加している．",
        "constructor_explanation": "コンストラクタ，頂点数$N$，マージ関数$mf$，遷移関数$rf$そして，単位元$i$で初期化する",
        "add_edge_explanation": "頂点$s$と頂点$t$を結ぶ辺を追加する．辺のデータは$d$",
        "build_explanation": "全方位木DPを構築する",
        "operator_reference_explanation": "頂点$v$を根とする木DPの結果を返す"
    }
}